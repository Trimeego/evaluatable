// Generated by CoffeeScript 1.3.3
var __hasProp = {}.hasOwnProperty,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

(function(name, definition) {
  var global, old, theModule;
  if (typeof define === "function") {
    return define(definition);
  } else if (typeof module !== "undefined" && module.exports) {
    return module.exports = definition();
  } else {
    theModule = definition();
    global = this;
    old = global[name];
    theModule.noConflict = function() {
      global[name] = old;
      return theModule;
    };
    return global[name] = theModule;
  }
})("Evaluatable", function() {
  /* 
  
  _.flatten in the only dependency on underscore, making local reference that 
  here so it can be easily replaced.
  */

  var ArrayProto, Evaluatable, matchType, nativeForEach, nativeReduce, _bind, _each, _flatten, _isArray, _isNumber, _reduce;
  if (false) {
    _flatten = _.flatten;
  } else {
    ArrayProto = Array.prototype;
    nativeForEach = ArrayProto.forEach;
    nativeReduce = ArrayProto.reduce;
    _bind = function(func, obj) {
      var args;
      args = _.rest(arguments, 2);
      return function() {
        return func.apply(obj || root, args.concat(arguments));
      };
    };
    _isArray = Array.isArray || function(obj) {
      return !!(obj && obj.concat && obj.unshift && !obj.callee);
    };
    _isNumber = function(obj) {
      return (obj === +obj) || toString.call(obj) === '[object Number]';
    };
    _each = function(obj, iterator, context) {
      var i, key, val, _i, _ref;
      try {
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (_isNumber(obj.length)) {
          for (i = _i = 0, _ref = obj.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (key in obj) {
            if (!__hasProp.call(obj, key)) continue;
            val = obj[key];
            iterator.call(context, val, key, obj);
          }
        }
      } catch (e) {
        if (e !== breaker) {
          throw e;
        }
      }
      return obj;
    };
    _reduce = function(obj, iterator, memo, context) {
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) {
          iterator = _bind(iterator, context);
        }
        return obj.reduce(iterator, memo);
      }
      _each(obj, function(value, index, list) {
        return memo = iterator.call(context, memo, value, index, list);
      });
      return memo;
    };
    _flatten = function(array) {
      return _reduce(array, function(memo, value) {
        if (_isArray(value)) {
          return memo.concat(_flatten(value));
        }
        memo.push(value);
        return memo;
      }, []);
    };
  }
  matchType = function(a, b) {
    var dt, n, ret;
    ret = b;
    if (a && b && (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b))) {
      switch (Object.prototype.toString.call(a)) {
        case "[object Number]":
          n = Number(b);
          if (n) {
            ret = n;
          }
          break;
        case "[object Date]":
          dt = Date.parse(b);
          if (dt) {
            ret = new Date(dt);
          }
      }
    }
    return ret;
  };
  Evaluatable = (function() {
    var _this = this;

    function Evaluatable(base) {
      this.evaluateConditionSet = __bind(this.evaluateConditionSet, this);

      this.average = __bind(this.average, this);

      this.count = __bind(this.count, this);

      this.max = __bind(this.max, this);

      this.min = __bind(this.min, this);

      this.sum = __bind(this.sum, this);

      this.none = __bind(this.none, this);

      this.all = __bind(this.all, this);

      this.any = __bind(this.any, this);

      this.evaluateKeyPath = __bind(this.evaluateKeyPath, this);

      this.evaluate = __bind(this.evaluate, this);

      this.kvc = __bind(this.kvc, this);

      this.valueForKeyPath = __bind(this.valueForKeyPath, this);
      this["super"] = base;
      this.evaluatables = {
        today: function() {
          return new Date();
        },
        now: function() {
          return new Date();
        }
      };
    }

    Evaluatable.prototype.valueForKeyPath = function(key) {
      var levels, nextLevel, ret, root;
      if (key && key.split) {
        levels = key.split(".");
        root = levels[0];
        if (root && root === 'evaluatable') {
          nextLevel = levels.slice(1).join('.');
          return this.evaluatables[nextLevel].call();
        } else {
          ret = this.kvc(key, this["super"]);
          if (ret && _isArray(root)) {
            return _flatten(ret);
          } else {
            if (!ret) {
              return null;
            } else {
              return ret;
            }
          }
        }
      } else {
        return null;
      }
    };

    Evaluatable.prototype.kvc = function(key, object, lvl) {
      var item, levels, nextLevel, root, _i, _len, _results;
      if (lvl == null) {
        lvl = 1;
      }
      levels = key.split(".");
      root = object[levels[0]];
      if (root) {
        nextLevel = levels.slice(1).join('.');
        if (levels.length === 1) {
          return root;
        } else {
          if (_isArray(root)) {
            _results = [];
            for (_i = 0, _len = root.length; _i < _len; _i++) {
              item = root[_i];
              _results.push(this.kvc(nextLevel, item, lvl + 1));
            }
            return _results;
          } else {
            return this.kvc(nextLevel, root, lvl + 1);
          }
        }
      } else {
        return null;
      }
    };

    Evaluatable.prototype.operators = {
      is: function(a, b) {
        return a === matchType(a, b);
      },
      isnt: function(a, b) {
        return a !== matchType(a, b);
      },
      isLessThan: function(a, b) {
        return a < matchType(a, b);
      },
      isGreaterThan: function(a, b) {
        return a > matchType(a, b);
      },
      startsWith: function(a, b) {
        if (_isArray(a)) {
          if (a.length > 0) {
            if (a[0] === matchType(a[0], b)) {
              return true;
            }
          }
        } else {
          if (a.toString().indexOf(b.toString()) === 0) {
            return true;
          }
        }
        return false;
      },
      contains: function(a, b) {
        var item;
        if (_isArray(a)) {
          if (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = a.length; _i < _len; _i++) {
              item = a[_i];
              if (item === matchType(item, b)) {
                _results.push(item);
              }
            }
            return _results;
          })()).length > 0) {
            return true;
          }
        } else {
          if (a.toString().indexOf(b) > -1) {
            return true;
          }
        }
        return false;
      }
    };

    Evaluatable.prototype.evaluate = function(a, operator, b) {
      var op;
      op = this.operators[operator];
      if (op) {
        return op(a, b);
      } else {
        return false;
      }
    };

    Evaluatable.prototype.evaluateKeyPath = function(keyPath, operator, value2) {
      var aggregator, key, op, _ref;
      _ref = keyPath.split(':'), key = _ref[0], aggregator = _ref[1];
      if (aggregator && this[aggregator]) {
        return this[aggregator].apply(this, [key, operator, value2]);
      } else {
        op = this.operators[operator];
        if (op) {
          return op(this.valueForKeyPath(keyPath), value2);
        } else {
          return false;
        }
      }
    };

    Evaluatable.prototype.any = function(keyPath, operator, value) {
      var arr, item, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          if (this.evaluate(item, operator, value)) {
            return true;
          }
        }
      }
      return false;
    };

    Evaluatable.prototype.all = function(keyPath, operator, value) {
      var arr, item, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          if (!this.evaluate(item, operator, value)) {
            return false;
          }
        }
      }
      return true;
    };

    Evaluatable.prototype.none = function(keyPath, operator, value) {
      var arr, item, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          if (this.evaluate(item, operator, value)) {
            return false;
          }
        }
      }
      return true;
    };

    Evaluatable.prototype.sum = function(keyPath, operator, value) {
      var arr, item, total, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        total = 0;
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          total += item;
        }
        return this.evaluate(total, operator, value);
      }
    };

    Evaluatable.prototype.min = function(keyPath, operator, value) {
      var arr, item, min, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        min = null;
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          if (!min || min > item) {
            min = item;
          }
        }
        return this.evaluate(min, operator, value);
      }
    };

    Evaluatable.prototype.max = function(keyPath, operator, value) {
      var arr, item, max, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        max = null;
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          if (!max || max < item) {
            max = item;
          }
        }
        return this.evaluate(max, operator, value);
      }
    };

    Evaluatable.prototype.count = function(keyPath, operator, value) {
      var arr;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        return this.evaluate(arr.length, operator, value);
      }
    };

    Evaluatable.prototype.average = function(keyPath, operator, value) {
      var arr, item, total, _i, _len;
      arr = this.valueForKeyPath(keyPath);
      if (arr) {
        total = 0;
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          total += item;
        }
        return this.evaluate(total / arr.length, operator, value);
      }
    };

    Evaluatable.prototype.evaluateConditionSet = function(conditionSet) {
      var condition, ret, returns, testValue, _i, _len, _ref, _ref1;
      returns = [];
      _ref = conditionSet.conditions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        condition = _ref[_i];
        if (condition.hasOwnProperty("conditions")) {
          returns.push(this.evaluateConditionSet(condition));
        } else {
          testValue = (_ref1 = this.valueForKeyPath(condition.value)) != null ? _ref1 : condition.value;
          returns.push(this.evaluateKeyPath(condition.property, condition.operator, testValue));
        }
      }
      if (conditionSet.aggregator === "any") {
        return ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = returns.length; _j < _len1; _j++) {
            ret = returns[_j];
            if (ret) {
              _results.push(ret);
            }
          }
          return _results;
        })()).length > 0;
      } else {
        return ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = returns.length; _j < _len1; _j++) {
            ret = returns[_j];
            if (!ret) {
              _results.push(ret);
            }
          }
          return _results;
        })()).length === 0;
      }
    };

    return Evaluatable;

  }).call(this);
  return Evaluatable;
});
